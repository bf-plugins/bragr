#! /usr/bin/env python

"""generate_wrapper.py

Uses ctypesgen to generate a python wrapper.
"""
import simplejson as json
from jinja2 import Template
import os
import subprocess
import crayons
import shutil

def get_SOABI():
    """ Get SO ABI suffix (e.g. cpython-39-x86_64-linux-gnu) """
    import sysconfig 
    ext_suffix = sysconfig.get_config_var('SOABI')
    return ext_suffix

SO_ABI_NAME = get_SOABI()

### COMMAND TO LAUNCH CTYPESGEN
ctypes_tpl = 'ctypesgen src/{{bn}}.h -obuild/{{bn}}.json -lbifrost -l{{build_path}}/{{libname}}.so -I. -I{{bf_src_path}} --no-embed-preamble --output-language=json'

### Template for ctypesgen wrapper
hdr_tpl= '''
""" {{libname}}_generated.py 

Python wrapper generated with bragr (bifrost)
"""

import os
from ctypesgen.libraryloader import load_library, add_library_search_dirs 
from ctypesgen.printer_python.preamble import *
from bifrost.libbifrost_generated import BFarray, BFstatus

# Add current path to search dirs
HERE = os.path.dirname(os.path.abspath(__file__))
load_library.other_dirs.append(HERE)

# Extension name depends on OS/Python version (SOABI)
python_extension_so_name = f'{{plugname}}.{{SO_ABI_NAME}}' # Nb: no '.so' needed

_libs={}
_libs["{{plugname}}"] = load_library(python_extension_so_name)

'''

### Template for wrapping a C function using ctypes
func_tpl = '''
for _lib in _libs.values():
    if not _lib.has("{{name}}", "cdecl"):
        continue
    _{{name}} = _lib.get("{{name}}", "cdecl")
    _{{name}}.argtypes = [{% for arg in args -%} 
    {%- if arg['Klass'] == 'CtypesPointer' -%} 
    POINTER({{arg['destination']['name']}}),
    {%- elif arg['Klass'] == 'CtypesTypedef' -%}
    {{arg['name']}},
    {%- else -%}
    c_{{arg['name']}},
    {%- endif -%}
    {%- endfor -%}]
    _{{name}}.restype = {{return['name']}}

    def {{name}}({% for arg in args %}{{arg['identifier']}}, {% endfor %}):
        """
        Python wrapper for _{{name}} -- generated by bragr (bifrost)
        Args:
            {% for arg in args %}
            {%- if arg['Klass'] == 'CtypesPointer' -%} 
            {{arg['identifier']}}: POINTER({{arg['destination']['name']}})
            {% else -%}        
            {{arg['identifier']}}: {{arg['name']}},
            {% endif -%}
    {% endfor %}
        """
        return _{{name}}({% for arg in args %}{{arg['identifier']}}, {% endfor %})
    {{name}}.argtypes = _{{name}}.argtypes
    {{name}}.restype = _{{name}}.restype
    
    break 

'''

### Template to deal with typedef structs python
typedef_tpl= '''
class struct_{{name}}(Structure):
    pass
{{name}} = POINTER(struct_{{name}})

'''

### Setup Jinja templates
j2_ctypes_tpl  = Template(ctypes_tpl)
j2_hdr_tpl     = Template(hdr_tpl)
j2_func_tpl    = Template(func_tpl)
j2_typedef_tpl = Template(typedef_tpl)

if __name__== "__main__":
    import argparse
    p = argparse.ArgumentParser(description='')
    p.add_argument('header_files', nargs='*', help='List of header files (*.h) to wrap')
    p.add_argument('-s', '--src_path', dest='src_path', type=str, default='./',
                   help='Location of bifrost source (.../bifrost/src)')
    p.add_argument('-l', '--lib_path', dest='lib_path', type=str, default='./',
                   help='Location of bifrost library (libbifrost.so)')
    p.add_argument('-b', '--build_path', dest='build_path', type=str, default='./build',
                   help='Location of meson build directory')
    p.add_argument('-n', '--plugname', dest='plugname', type=str, default='bf_plugin',
                   help='Name of plugin (e.g. bf_boxcar)')
    args = p.parse_args()
    
    # Form dict to be used inside jinja templates
    header_files = args.header_files
    hdr = {
        'libname': f'lib{args.plugname}',
        'plugname': args.plugname,
        'bf_src_path': args.src_path,
        'bf_lib_path': args.lib_path,
        'build_path':  args.build_path,
        'SO_ABI_NAME': SO_ABI_NAME
        }

    fn_out = 'build/'+hdr['libname'] + '_wrapper.py'
    
    # Write out Python wrapper preamble
    with open(fn_out, 'w') as fh :
        fh.write(j2_hdr_tpl.render(hdr))

    # Read .h headers and generate ctypesgen JSON
    for header_file in header_files:
        hdr['bn']= os.path.splitext(os.path.basename(header_file))[0]
        ctypes_cmd = j2_ctypes_tpl.render(hdr)

        # Run ctypesgen
        print(crayons.green(ctypes_cmd))
        output = subprocess.run(ctypes_cmd.split(' '),  check=True, capture_output=True)
        outmsg = output.stderr.decode('ascii')

        if "ERROR" in outmsg:
            print(outmsg)
            print(crayons.red("ctypesgen error detected, exiting...", bold=True))
            exit()
    
        # load JSON from ctypesgen
        fn_in = os.path.join('build', hdr['bn'] + '.json')
        with open(fn_in) as fh:
            d = json.load(fh)  

        # Generate Python wrapper for each function
        for item in d:
            name = item['name']
            if item['type'] == 'function':
                print(crayons.white(f"Wrapping {name}...", bold=True))
                func = item
                with open(fn_out, 'a') as fh:
                    fh.write(j2_func_tpl.render(func))
            if item['type'] == 'typedef':
                typedef = item
                if typedef['name'] not in ('BFbool', 'BFarray', 'BFstatus', 'BFspace', 'BFdtype', 'BFdarray'):
                    print(crayons.white(f"Wrapping typedef {name}...", bold=True))
                    with open(fn_out, 'a') as fh:
                        fh.write(j2_typedef_tpl.render(typedef))

    # Copy to python package
    shutil.copy(fn_out, 'pythonsrc')
    print(crayons.white(f"Wrapper written to {fn_out}", bold=True))
